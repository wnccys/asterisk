use std::cell::RefCell;
use std::rc::Rc;

use crate::chunk::OpCode;
use crate::parser::scanner::TokenCode;
use crate::parser::Parser;
use crate::value::{Modifier, Primitive, Type, Value};

#[derive(Debug, PartialEq, PartialOrd)]
/// Defines lower to higher operation precedence order.
///
pub enum Precedence {
    None,
    Assignment, // =
    Or,         // or
    And,        // and
    Equality,   // == !=
    Comparison, // < > <= >=
    Term,       // + -
    Factor,     // * /
    Unary,      // ! -
    Call,       // . ()
    Primary,
}

impl Precedence {
    fn increment(&mut self) {
        *self = match self {
            Self::None => Self::None,
            Self::Assignment => Self::Or,
            Self::Or => Self::And,
            Self::And => Self::Equality,
            Self::Equality => Self::Comparison,
            Self::Comparison => Self::Term,
            Self::Term => Self::Factor,
            Self::Factor => Self::Unary,
            Self::Unary => Self::Call,
            Self::Call => Self::Primary,
            Self::Primary => panic!("Cannot increment primary precedence."),
        }
    }
}

/// Determine which Rules are equivalent to which Token.
///
#[derive(Debug)]
pub struct ParseRule {
    pub prefix: fn(&mut Parser, bool),
    pub infix: fn(&mut Parser, bool),
    pub precedence: Precedence,
}

/// Dummy prefix Rule.
/// Every Token shall have a prefix, this one is a placeholder over the ones whose emit no Bytecodes.
///
fn none(_parser: &mut Parser, _can_assign: bool) {}

/// Handle "()" precedence operator consuming ")" on end.
///
fn grouping(parser: &mut Parser, _can_assign: bool) {
    parser.expression();
    parser.consume(TokenCode::RightParen, "expected ')' after expression.");
}

/// Get number as string and parses it to the number itself, setting it on the constants (immediatelly) and stack (via the generated bytecode) vector.
///
fn number(parser: &mut Parser, _can_assign: bool) {
    // Gets slice containing token stringify'ed number (token start .. token length);
    let value = &parser.previous.unwrap().lexeme;

    if value.contains('.') {
        let float_value: f64 = value.parse().expect("invalid float value.");

        parser.emit_constant(Value {
            value: Primitive::Float(float_value),
            _type: Type::Float,
            modifier: Modifier::Unassigned,
        });
    } else {
        let int_value: i32 = value.parse().expect("invalid int value.");

        parser.emit_constant(Value {
            value: Primitive::Int(int_value),
            _type: Type::Int,
            modifier: Modifier::Unassigned,
        });
    }
}

/// Distinguish between negate (!) and minus (-) operations.
///
fn unary(parser: &mut Parser, _can_assign: bool) {
    let operator_type = &parser.previous.unwrap().code;

    parser.parse_precedence(Precedence::Unary);

    match operator_type {
        TokenCode::Bang => parser.emit_byte(OpCode::Not),
        TokenCode::Minus => parser.emit_byte(OpCode::Negate),
        _ => (),
    }
}

/// Parse math operators recursivelly until all operations are evaluated in correct order.
///
fn binary(parser: &mut Parser, _can_assign: bool) {
    let operator_type = &parser.previous.unwrap().code;

    let mut rule = get_rule(&operator_type);
    rule.precedence.increment();

    parser.parse_precedence(rule.precedence);

    if let Some(token) = Some(operator_type) {
        match token {
            TokenCode::Plus => parser.emit_byte(OpCode::Add),
            TokenCode::Minus => {
                parser.emit_byte(OpCode::Negate);
                parser.emit_byte(OpCode::Add)
            }
            TokenCode::Star => parser.emit_byte(OpCode::Multiply),
            TokenCode::Slash => parser.emit_byte(OpCode::Divide),
            TokenCode::BangEqual => {
                parser.emit_byte(OpCode::Equal);
                parser.emit_byte(OpCode::Not);
            }
            TokenCode::EqualEqual => parser.emit_byte(OpCode::Equal),
            TokenCode::Greater => parser.emit_byte(OpCode::Greater),
            TokenCode::GreaterEqual => {
                parser.emit_byte(OpCode::Less);
                parser.emit_byte(OpCode::Not);
            }
            TokenCode::Less => parser.emit_byte(OpCode::Less),
            TokenCode::LessEqual => {
                parser.emit_byte(OpCode::Greater);
                parser.emit_byte(OpCode::Not);
            }
            _ => panic!("invalid binary call."),
        }
    }
}

/// Emit bool values Bytecodes.
///
fn literal(parser: &mut Parser, _can_assign: bool) {
    match parser.previous.unwrap().code {
        TokenCode::True => parser.emit_byte(OpCode::True),
        TokenCode::False => parser.emit_byte(OpCode::False),
        _ => panic!("invalid literal operation."),
    }
}

// TODO Set string interning model
/// Emit String to Contants.
///
/// Emit: Constant
///
fn string(parser: &mut Parser, _can_assign: bool) {
    let str = &parser.previous.unwrap().lexeme;

    let index = parser.function.chunk.write_constant(Primitive::String(str.clone()));
    parser.emit_byte(OpCode::Constant(index));
}

/// & -> Reference
/// -> Get current token (Value to-be-parsed)
/// -> Emit bytecode which set referenced named variable to the stack
/// -> Ref must reference the value in the stack itself
/// 
/// 
fn reference(parser: &mut Parser, _can_assign: bool) {
    parser.advance();

    match parser.scopes.len() {
        0 => {
                let var_index = parser.identifier_constant();
                parser.emit_byte(OpCode::SetRefGlobal(var_index));
        },
        _ => {
            let var_index = parser
                .scopes
                .last()
                .unwrap()
                .get_local(parser.previous.unwrap().lexeme.clone())
                .unwrap_or_else(
                    || panic!("Invalid variable name: {}", parser.previous.unwrap().lexeme)
                );

            parser.emit_byte(OpCode::SetRefLocal(var_index.borrow().0));
        },
    }
}

fn variable(parser: &mut Parser, can_assign: bool) {
    named_variable(parser, can_assign);
}

/// Distinguish between re-assign and get variable already set value as well as local and global variables.
///
/// Emit: (Local set or get) or (Global set or get Bytecode).
///
fn named_variable(parser: &mut Parser, can_assign: bool) {
    let (get_op, set_op): (OpCode, OpCode);

    let scopes = &mut parser.scopes;

    if scopes.len() > 0 {
        let mut local: Option<Rc<RefCell<(usize, Modifier)>>> = None;

        /* Pass check on all scopes */
        for scope in scopes { 
            local = scope.get_local(parser.previous.unwrap().lexeme.clone());

            if local.is_some() { break; }
        }

        /* Global variables inside scope handling */
        if local.is_none() {
            let var_index = parser.identifier_constant();

            get_op = OpCode::GetGlobal(var_index);
            set_op = OpCode::SetGlobal(var_index);
        } else {
            let local = local.unwrap();

            get_op = OpCode::GetLocal(local.borrow().0);
            set_op = OpCode::SetLocal(local.borrow().0, local.borrow().1);
        }
    } else {
        let var_index = parser.identifier_constant();

        get_op = OpCode::GetGlobal(var_index);
        set_op = OpCode::SetGlobal(var_index);
    }

        println!("\n\n");
    if can_assign && parser.match_token(TokenCode::Equal) {
        parser.expression();
        parser.emit_byte(set_op);
    } else {
        parser.emit_byte(get_op);
    }
}


/// Jump if first condition of expression is false, verifying the second for a possible jump.
/// 
fn and_(parser: &mut Parser, _can_assign: bool) {
    let end_jump = parser.emit_jump(OpCode::JumpIfFalse(0));
    
    parser.emit_byte(OpCode::Pop);
    parser.parse_precedence(Precedence::And);

    parser.patch_jump(end_jump, OpCode::JumpIfFalse(0));
}

/// Verify for dangling expression on stack, jumpiong to the second evaluation and jumping over the entire instructions if false.
/// 
fn or_(parser: &mut Parser, _can_assign: bool) {
    let else_jump = parser.emit_jump(OpCode::JumpIfFalse(0));
    let end_jump = parser.emit_jump(OpCode::Jump(0));

    parser.patch_jump(else_jump, OpCode::JumpIfFalse(0));
    parser.emit_byte(OpCode::Pop);

    parser.parse_precedence(Precedence::Or);
    parser.patch_jump(end_jump, OpCode::Jump(0));
}

/// Get argument count by evaluating expression on function arguments.
/// 
fn call(parser: &mut Parser, _can_assign: bool) {
    let arg_count = arg_list(parser);

    parser.emit_byte(OpCode::Call(arg_count));
}

fn arg_list(parser: &mut Parser) -> usize {
    let mut arg_count = 0;

    if !parser.check(TokenCode::RightParen) {
        loop {
            parser.expression();
            arg_count += 1;

            if !parser.match_token(TokenCode::Comma) { break; }
        }
    }
    parser.consume(TokenCode::RightParen, "Expect ')' after function arguments.");

    arg_count
}

/// Define which tokens will call which functions on prefix or infix while it's precedence is being parsed.
///
pub fn get_rule(token_code: &TokenCode) -> ParseRule {
    match token_code {
        TokenCode::LeftParen => ParseRule {
            prefix: grouping,
            infix: call,
            precedence: Precedence::Call,
        },
        TokenCode::RightParen => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::LeftBrace => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::RightBrace => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Comma => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Dot => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Minus => ParseRule {
            prefix: unary,
            infix: binary,
            precedence: Precedence::Term,
        },
        TokenCode::Plus => ParseRule {
            prefix: none,
            infix: binary,
            precedence: Precedence::Term,
        },
        TokenCode::Colon => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::SemiColon => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Slash => ParseRule {
            prefix: none,
            infix: binary,
            precedence: Precedence::Factor,
        },
        TokenCode::Ampersand => ParseRule {
            prefix: reference,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Star => ParseRule {
            prefix: none,
            infix: binary,
            precedence: Precedence::Factor,
        },
        TokenCode::Bang => ParseRule {
            prefix: unary,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::BangEqual => ParseRule {
            prefix: none,
            infix: binary,
            precedence: Precedence::Equality,
        },
        TokenCode::Default => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Equal => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::EqualEqual => ParseRule {
            prefix: none,
            infix: binary,
            precedence: Precedence::Equality,
        },
        TokenCode::Greater => ParseRule {
            prefix: none,
            infix: binary,
            precedence: Precedence::Comparison,
        },
        TokenCode::GreaterEqual => ParseRule {
            prefix: none,
            infix: binary,
            precedence: Precedence::Comparison,
        },
        TokenCode::Less => ParseRule {
            prefix: none,
            infix: binary,
            precedence: Precedence::Comparison,
        },
        TokenCode::LessEqual => ParseRule {
            prefix: none,
            infix: binary,
            precedence: Precedence::Comparison,
        },
        TokenCode::Identifier => ParseRule {
            prefix: variable,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::String => ParseRule {
            prefix: string,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Number => ParseRule {
            prefix: number,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::And => ParseRule {
            prefix: none,
            infix: and_,
            precedence: Precedence::And,
        },
        TokenCode::Class => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Case => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Else => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::False => ParseRule {
            prefix: literal,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::For => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Fun => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::If => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Modifier => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Nil => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Or => ParseRule {
            prefix: none,
            infix: or_,
            precedence: Precedence::Or,
        },
        TokenCode::Print => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Switch => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Return => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Continue  => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Super => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::TypeDef(_) => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::This => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::True => ParseRule {
            prefix: literal,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Var => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Const => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::While => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Error(_) => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Eof => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
        TokenCode::Comment => ParseRule {
            prefix: none,
            infix: none,
            precedence: Precedence::None,
        },
    }
}
